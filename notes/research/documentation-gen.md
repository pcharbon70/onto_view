**Designing an Ontology Documentation Generator with Phoenix LiveView**

**Introduction and Objectives**

Domain scientists and software developers often need to explore complex OWL ontologies in a user-friendly way. Traditional ontology documentation tools (like static HTML pages) can be cumbersome or overwhelming for casual users[semantic-web-journal.net](https://www.semantic-web-journal.net/system/files/swj1114.pdf#:~:text=consequence%2C%20an%20increasing%20num%02ber%20of,%2ACorresponding%20author)[semantic-web-journal.net](https://www.semantic-web-journal.net/system/files/swj1114.pdf#:~:text=experts,Section%202%20of%20this%20article). Our goal is to design a **modern, interactive ontology documentation tool** using Elixir's Phoenix LiveView. This tool will generate a web-based documentation site for one or more interrelated OWL ontologies (e.g., the _elixir-core_ ontology and its imports). It must represent the entire OWL schema of the ontologies - including classes, properties, and their relationships - while providing an intuitive user experience. Key objectives include:

- **Comprehensive OWL coverage:** Document all ontology elements (classes, object/data properties, individuals, etc.) with their definitions, annotations (labels, comments), and logical relationships (subclass hierarchy, domains, ranges, equivalences, etc.) in a human-readable form[ceur-ws.org](https://ceur-ws.org/Vol-932/paper12.pdf#:~:text=Abstract,ontologies%2C%20Web%20tool%2C%20ontology%20documentation)[dgarijo.github.io](https://dgarijo.github.io/Widoco/doc/gallery/#:~:text=). All relationships (e.g. subclass links or property references) should be navigable hyperlinks to the referenced entity for easy traversal.
- **User-friendly navigation:** Use the latest UI/UX best practices to avoid overwhelming the user. The interface should allow **easy scanning and exploration** of the ontology without requiring deep ontology expertise. For instance, leveraging **progressive disclosure** via accordions can reduce clutter and cognitive load by showing details on demand[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Reducing%20Clutter). The system should feel familiar to software developers (e.g. clear organization, search functionality) while introducing semantic web concepts gently.
- **Dynamic and responsive:** Implement the tool as a dynamic web application (Phoenix LiveView) so users can interact (expand sections, filter terms, switch views) with immediate feedback, without page reloads. This enables features like live search filtering and interactive graph visualization updates in real time.
- **Visual exploration:** Incorporate a **graph-based visualization** of the ontology to complement the text documentation. Visualizing the ontology helps users grasp the structure and relationships intuitively[linkedin.com](https://www.linkedin.com/pulse/exploring-owl-ontologies-visually-paradigm-shift-nicolas-figay-telxe#:~:text=Why%20Visual%20Exploration%20Matters%3A). The tool should support an interactive graph view (e.g. using a force-directed layout or the VOWL notation) so users can see classes and relationships as a network diagram and even filter or highlight parts of the graph.
- **Download and metadata:** Provide options to download the ontology files (TTL/OWL) and display key metadata (version, authors, imports, etc.). The documentation homepage can summarize the ontology's purpose and top-level metadata, helping users quickly understand context (similar to how WIDOCO includes an overview and how-to-cite section[dgarijo.github.io](https://dgarijo.github.io/Widoco/doc/gallery/#:~:text=)).

By meeting these objectives, the tool will serve as a convenient ontology browser for the _elixir-core_ ontology and its dependencies, tailored to the needs of developers and domain experts.

**Learning from Existing Tools and Research**

To design an effective solution, we can draw inspiration from existing ontology documentation and visualization tools:

- **LODE & WIDOCO (Static Documentation):** _Live OWL Documentation Environment (LODE)_ generates human-readable HTML pages for ontologies, capturing all classes, properties, axioms, and annotations in a single-page format[ceur-ws.org](https://ceur-ws.org/Vol-932/paper12.pdf#:~:text=Abstract,ontologies%2C%20Web%20tool%2C%20ontology%20documentation)[ceur-ws.org](https://ceur-ws.org/Vol-932/paper12.pdf#:~:text=In%20this%20paper%20we%20introduce,by%20means%20of%20embedded%20links). It organizes content similar to W3C recommendation pages, with embedded links for navigation. _WIDOCO_ is a more recent tool that builds on LODE to produce enriched documentation; it creates a cross-reference of classes, properties, data properties, and individuals along with their definitions[dgarijo.github.io](https://dgarijo.github.io/Widoco/doc/gallery/#:~:text=). These tools ensure completeness, but their output is static. They lack interactive features like on-the-fly filtering or dynamic visuals. Our LiveView-based tool will similarly present a thorough cross-reference, but improve on interactivity and modern UX.
- **WebVOWL and Visual Notations:** Visual representations of ontologies have been shown to improve comprehension for users unfamiliar with OWL[semantic-web-journal.net](https://www.semantic-web-journal.net/system/files/swj1114.pdf#:~:text=ontologies,intuitive%20and%20comprehensible%20ontology%20visualizations)[linkedin.com](https://www.linkedin.com/pulse/exploring-owl-ontologies-visually-paradigm-shift-nicolas-figay-telxe#:~:text=Why%20Visual%20Exploration%20Matters%3A). WebVOWL is a web application implementing the VOWL (Visual Notation for OWL) standard, which depicts ontologies as intuitive node-link diagrams[semantic-web-journal.net](https://www.semantic-web-journal.net/system/files/swj1114.pdf#:~:text=are%20combined%20to%20a%20force,VOWL%20by%20means%20of%20various). In fact, WIDOCO integrates WebVOWL to offer an **interactive graph** in its documentation, allowing users to visually filter and browse ontology concepts[dgarijo.github.io](https://dgarijo.github.io/Widoco/doc/gallery/#:~:text=). This confirms the value of combining text and graph views. We plan to adopt a similar approach: incorporate a graph visualization (possibly using a library or adapting WebVOWL's approach) to present classes and relationships in an intuitive way. The VOWL notation, which was validated by user studies to produce "comparatively intuitive and comprehensible ontology visualizations"[semantic-web-journal.net](https://www.semantic-web-journal.net/system/files/swj1114.pdf#:~:text=ontologies,intuitive%20and%20comprehensible%20ontology%20visualizations), can guide our graph design so that even non-ontology-experts can understand the diagrams.
- **Ontology Browsers and Editors:** Tools like Protégé (with OntoGraf plugin) and the EMBL-EBI Ontology Lookup Service provide UIs for exploring ontologies. Protégé's UI is powerful but oriented to ontology engineers (with editing capabilities and complex dialogs). In contrast, our focus is a read-only _viewer_ for end-users. Still, features from these tools are useful references. For example, Protégé's OntoGraf shows class relationships as a graph, and OLS provides a search-focused interface with a hierarchical tree of terms. We want to combine the best of these: a **hierarchical list (accordion/tree)** for structured navigation plus an **optional graph view** for visual insight. Recent discussions in the community even propose new ways to visualize object properties (treating domain and range as first-class nodes rather than just edges) to better illustrate relationships[linkedin.com](https://www.linkedin.com/pulse/exploring-owl-ontologies-visually-paradigm-shift-nicolas-figay-telxe#:~:text=Proposals%20to%20actually%20visualize%20domain,and%20range%20of%20properties). Our design can remain flexible to accommodate such improvements (e.g., toggling different graph display modes for properties).
- **Technical Approaches:** The backend of our tool can leverage Semantic Web libraries and practices. Similar projects (e.g., OntoGraph by NinePts) have used triple stores and SPARQL to gather ontology details for visualization[github.com](https://github.com/NinePts/OntoGraph#:~:text=The%20code%20consists%20of%20a,Applied%20Ontology%20from%20IOS%20Press). We can apply a lightweight version of this: parse the Turtle files and query the data (in-memory) to fetch all classes, their properties, etc. Using SPARQL or an Elixir RDF library to retrieve "classes, properties, individuals" programmatically ensures we don't miss any relationship when building the docs[github.com](https://github.com/NinePts/OntoGraph#:~:text=The%20code%20consists%20of%20a,Applied%20Ontology%20from%20IOS%20Press). This automated gathering of ontology terms and links is crucial for maintainability, so the documentation updates whenever the ontology changes (especially important if the ontologies are evolving, like the _elixir-evolution_ module suggests).

By understanding these existing tools and research insights, we can avoid their pitfalls and incorporate their strengths. In summary, **our tool will extend the static documentation paradigm (LODE/WIDOCO) with LiveView-powered interactivity and integrate proven visualization techniques (like VOWL graphs) to enhance user understanding.**

**System Design and Architecture**

To meet the requirements, the system will be organized into several components, both on the backend (ontology processing) and frontend (LiveView interface):

- **Ontology Parsing and Data Model:** We will develop or use an RDF/OWL parsing library in Elixir to load the ontology files (Turtle format). All imported ontologies (e.g., _elixir-core_ importing _elixir-otp_, _elixir-structure_, etc.) will be loaded so that the full set of triples is available. This parsing step will identify ontology entities: Classes (owl:Class), Object Properties (owl:ObjectProperty), Data Properties, Individuals, and Annotation properties. We'll build an in-memory representation or use a triple-store-like structure for querying. Key relationships such as subclass hierarchies (rdfs:subClassOf), domain/range (rdfs:domain, rdfs:range), equivalence (owl:equivalentClass), and annotations (rdfs:label, rdfs:comment, etc.) will be extracted. Using these, we can pre-compute structures like a class hierarchy tree, lists of properties grouped by domain/range, etc., or query them on the fly. The approach is similar to running SPARQL queries against the ontology model to retrieve needed information[github.com](https://github.com/NinePts/OntoGraph#:~:text=The%20code%20consists%20of%20a,Applied%20Ontology%20from%20IOS%20Press), ensuring our documentation is derived directly from the ontology's axioms and annotations (as LODE does[ceur-ws.org](https://ceur-ws.org/Vol-932/paper12.pdf#:~:text=Abstract,ontologies%2C%20Web%20tool%2C%20ontology%20documentation)).
- **Phoenix LiveView Backend:** Phoenix LiveView will handle the web interface without heavy client-side JavaScript frameworks. The server will maintain the state of the UI (e.g., which class is currently selected, current search filter text, which sections are expanded) and push HTML updates to the browser on events. This is ideal for our use case: for example, when a user types in the search box or selects a filter, a LiveView event can trigger a re-computation of the filtered class list on the server, and the updated list is sent to the client seamlessly. The LiveView process can also manage the generation of graph data (e.g., preparing JSON of nodes/edges for the current view) and send it to a client hook for visualization. Because LiveView keeps the UI state on the server, users can easily share links or refresh without losing context (we can even make the current selected class or view mode part of the URL for deep linking). The LiveView architecture also simplifies **synchronizing the accordion and graph** views - since both can be rendered from the same state. For instance, if a user clicks a class in the accordion list, the server knows the selected class and can both highlight that class's detail panel and also send an update to the graph component (e.g., to focus or zoom into that class's node).
- **Graph Visualization Integration:** For the graph-based interface, we will integrate a front-end visualization library. Options include using an existing library like **WebVOWL** (open-source) or a generic graph library (D3.js, Cytoscape.js, Sigma.js) configured to display ontological relationships. WebVOWL provides a ready-made ontology visualization with the VOWL notation, which emphasizes understandability[semantic-web-journal.net](https://www.semantic-web-journal.net/system/files/swj1114.pdf#:~:text=the%20visual%20scope%20and%20completeness,intuitive%20and%20comprehensible%20ontology%20visualizations). We could embed WebVOWL by feeding it our ontology (it accepts JSON exports of OWL ontologies) - WIDOCO, for example, does something similar to show an interactive diagram[dgarijo.github.io](https://dgarijo.github.io/Widoco/doc/gallery/#:~:text=). Alternatively, a custom D3 visualization can be built: LiveView's JS hooks would allow us to mount a D3 force-directed graph that listens for updates (like data for nodes to highlight or filter). The visualization will depict classes as nodes (possibly with different shapes/colors for classes vs. individuals or for different ontologies), and relationships as edges. **Object properties** can be shown as labeled edges between class nodes (with the property name), which is a straightforward approach. We will however be mindful of scenarios like properties with many domains/ranges - recent UX suggestions recommend visualizing such properties more explicitly[linkedin.com](https://www.linkedin.com/pulse/exploring-owl-ontologies-visually-paradigm-shift-nicolas-figay-telxe#:~:text=Proposals%20to%20actually%20visualize%20domain,and%20range%20of%20properties). In a future iteration, we could represent properties as nodes connecting to special "Domain" and "Range" nodes for a richer view, possibly toggling this mode. Initially, the simpler edge representation (as seen in Protégé's OntoGraf or WebVOWL) should suffice for clarity. The graph view will include basic controls: zoom/pan, a legend or toggle for ontology modules (if multiple ontologies, e.g., highlight classes from _elixir-core_ vs _elixir-otp_ in different colors), and the ability to click on a node to open that class's detailed documentation. A **search box** in the graph view helps locate a specific class or property by name (a feature present in WebVOWL【19†look】 and one we will include for usability).
- **Accordion-Style Class Explorer:** The primary textual navigation will be implemented as an accordion or tree interface listing all classes (and possibly properties) in a structured way. Using an accordion (collapsible sections) supports **progressive disclosure**: the user sees an overview of ontology terms and can expand only those they care about, reducing information overload[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Conveying%20an%20Overview%20of%20the,Page)[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Improving%20Scannability). We envision two possible approaches for the accordion structure:
  - **Hierarchy tree:** Present the class taxonomy as an expandable tree. Top-level classes (those without any superclasses, or only under owl:Thing) appear as top accordion headings. The user can expand a class to reveal its subclasses, and so on. This mirrors the ontology's subclass structure in a navigable form. Such a tree gives an immediate sense of how concepts are organized. Each class node in the tree could be clickable to show its detailed info on the right side (master-detail style), or the tree item itself may expand into an accordion panel containing details (see next point).
  - **Alphabetical list with expandable details:** Alternatively (or additionally), list all classes alphabetically, where each class name is an accordion header and its details (description, relations) are in the collapsible panel. This is similar to how LODE/WIDOCO outputs a long list of class definitions[dgarijo.github.io](https://dgarijo.github.io/Widoco/doc/gallery/#:~:text=Widoco%20builds%20on%20top%20of,the%20annotation%20of%20ontology%20concepts), but we make it interactive. A filter textbox can narrow this list to matching classes in real time, so users can quickly find a term by name (which is crucial in ontologies with dozens or hundreds of classes). For example, typing "Process" would filter the accordion to only classes whose name or label contains "Process". Users can then expand the desired class to see the details.

Both approaches could be combined: e.g., a sidebar tree for quick hierarchy navigation and a main panel showing the selected class's details. We will likely implement the **class detail view** as a separate LiveView component that updates when a class is selected, displaying all information about that class.

- **Class Detail View:** When a class is selected (either by clicking in the tree, or expanding it in the accordion list), the tool will show a detailed description. This includes:
  - The class name (label) and perhaps the full IRI (for unambiguous reference, especially if multiple ontologies with different prefixes are loaded).
  - Annotations like **rdfs:comment** (a textual description or definition of the class). This helps domain scientists understand the intended meaning. If the ontology uses rich annotations (possibly even examples or usage notes), all should be shown. The tool can format these nicely (even supporting Markdown if present, similar to WIDOCO's markdown support[dgarijo.github.io](https://dgarijo.github.io/Widoco/doc/gallery/#:~:text=Image%3A%20markdown%20support)).
  - **Superclass (parents):** list of direct superclasses (with links). Possibly show the class hierarchy above it (e.g., Thing > ... > Parent > Class).
  - **Subclasses (children):** list of any direct subclasses, each linking to those class pages. This acts as a local navigation for exploring more specific concepts.
  - **Equivalent Classes or Synonyms:** if owl:equivalentClass axioms exist, list them (these might be in imported ontologies, so it's useful to show if Class A ≡ Class B in another ontology).
  - **Disjoint Classes:** if declared, list those too (for completeness of OWL schema representation).
  - **Properties involving the class:** This part is important for "relationships leading to referenced class." We will list object and data properties that relate to this class in some way:
    - **Domain:** any object or data property for which this class is specified as (or is a subclass of) the domain. We can phrase it as "**Properties for which this class is a domain:** e.g. _hasMember_ (domain: Organization, range: Person)". Or in a more user-friendly phrasing, perhaps "**Outbound relations:** Organization _hasMember_ → Person." Each property name would link to a property detail page (if we provide one) or at least indicate the range class (which itself is a link to that class). In the WIDOCO example documentation, a class page shows "is in domain of: founded in, has member …" which are properties where that class is domain【18†look】.
    - **Range:** likewise, list properties for which this class is in the range (meaning other classes point to this class via those properties). For instance, _Organization_ might be range of _partOf_ (something _partOf_ Organization) - the documentation would list "**Incoming relations:** partOf (domain: Project, range: Organization)" or as WIDOCO shows, "is in range of: part of"【18†look】. This helps users see how a class is connected in the ontology graph.
    - We may also list **attributes/data properties** of the class (data properties that have this class as domain). And possibly any **restrictions** defined on the class (for OWL DL detail, e.g., if class has a restriction like "hasAge only xsd:integer", though this might be too detailed for a first version).
  - **Examples / Individuals:** If the ontology includes named individuals (instances) of this class, we can list a few as examples (with links to an Individuals section). For domain scientists, seeing examples can clarify the class's meaning. In the sample screenshot, _Organization_ had an example individual "University of Southern California"【18†look】. We can support an "Individuals" accordion section as well, or simply list instances on the class page.

This class detail template ensures we "represent the whole OWL schema" by including all relevant facets of a class. All the hyperlinks (to superclasses, subclasses, properties, individuals) make the documentation hypertext, letting users jump around easily-just as LODE emphasized ease of browsing via embedded links[ceur-ws.org](https://ceur-ws.org/Vol-932/paper12.pdf#:~:text=is%20an%20online%20service%20that,usually%20start%20by%20consulting%20its).

_Example of a class documentation section (from a WIDOCO-generated page). The class_ **_Organization_** _is shown with its IRI, definition, an example instance, and the relationships involving it (properties where Organization is in domain or range). Our tool will present similar information for each class._[dgarijo.github.io](https://dgarijo.github.io/Widoco/doc/gallery/#:~:text=Widoco%20builds%20on%20top%20of,the%20annotation%20of%20ontology%20concepts)【18†look】

- **Property and Other Term Views:** In addition to classes, the tool should document object properties and data properties in a similar fashion. There could be an "All Properties" list or they could be viewed when clicking the property links from class pages. A property detail view would show its domain(s) and range(s), any subproperty hierarchy, characteristics (functional, symmetric, etc.), and annotations (e.g., rdfs:comment describing the property's meaning). This is important since OWL object properties are first-class elements of the ontology (often under-appreciated in simple class-centric views)[linkedin.com](https://www.linkedin.com/pulse/exploring-owl-ontologies-visually-paradigm-shift-nicolas-figay-telxe#:~:text=Properties%20Are%20Not%20Just%20Data,Attributes)[linkedin.com](https://www.linkedin.com/pulse/exploring-owl-ontologies-visually-paradigm-shift-nicolas-figay-telxe#:~:text=Exploring%20OWL%20ontologies%20visually%20helps,traditional%20data%20structures%20can%27t%20match). By giving properties their own pages, we ensure a complete documentation. The UI could have a second accordion or section for "Properties" separate from "Classes" for direct access. However, if the ontology is large, we might rely on search to find properties by name. (The design should be flexible: e.g., a tab interface where one tab is "Classes" and another is "Properties" might work, each with its own list and filter.)
- **Search and Filtering:** A prominent search bar will allow users to quickly locate terms. We intend to support **live search**: as the user types a few letters, the list of classes/properties filters down. This helps users deal with large ontologies by reducing information overload to relevant hits. Filters could go beyond text search - for instance, checkboxes or dropdowns to filter by ontology (if multiple ontologies are loaded, e.g., show only core vs extension classes), or by type (class/property). For example, a user might filter to only show classes from _elixir-otp.ttl_ to focus on OTP-specific terms. Good filter design will follow UX best practices such as offering predictable categories and not overwhelming with too many filter options[nngroup.com](https://www.nngroup.com/articles/filter-categories-values/#:~:text=Helpful%20Filter%20Categories%20and%20Values,free%20of%20jargon%2C%20and%20prioritized). The LiveView backend can handle filtering efficiently (possibly indexing terms for quick lookup). This dynamic filtering aligns with the idea that users want to narrow content quickly rather than scroll through a huge list[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Minimizing%20Scrolling)[ux.stackexchange.com](https://ux.stackexchange.com/questions/5033/filtering-through-a-large-table-of-data-thoughts#:~:text=Filtering%20through%20a%20large%20table,would%20filter%20the%20table%20below).
- **Download and API Access:** The interface will include a clear option to download the ontology files (or the merged ontology) in Turtle or other formats. This could simply be a link or button on the main page (with the file served from Phoenix static files or generated on the fly). Additionally, because this tool is for developers, we might provide an API or at least document the URI of classes (so that they know how to programmatically access terms). For example, each class's page could be at a stable URL (maybe based on the class IRI fragment). This is similar to how published vocabularies allow content negotiation - WIDOCO actually sets up .htaccess for vocab URLs[dgarijo.github.io](https://dgarijo.github.io/Widoco/doc/gallery/#:~:text=), but in our Phoenix app we can route /docs/ontology/ClassName to the class view. Ensuring that the _documentation is easily accessible and shareable_ (copy-paste a link to a class) is a usability boost for developers.

**User Interface and Experience Design**

With the architecture in mind, we focus on delivering a **clean, modern UI** that balances rich information with ease of use:

- **Layout:** A two-column responsive layout can work well. For example, a left sidebar can hold the navigation (search box, list of classes/properties in an accordion or tree), and a right pane shows the content (either a class detail view or a graph or a welcome page). On smaller screens (if used on tablets), the sidebar can collapse into a menu. The design will use a modern CSS framework (Phoenix typically integrates with Tailwind CSS by default) to ensure a clean look and mobile-responsive behavior.
- **Accordions for Navigation:** We will utilize accordion UI components (expand/collapse panels) for organizing content-heavy sections in a logical, collapsible way. According to UX research, accordions can act as a **"mini-IA" (information architecture) of a page**[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Accordions%20are%20versatile,are%20key%20advantages%20of%20accordions)[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Conveying%20an%20Overview%20of%20the,Page), giving users an at-a-glance overview of content sections (in our case, ontology terms) while keeping the page from becoming too cluttered. Each accordion heading will be descriptive (e.g., the class name and perhaps a one-line summary if available) to serve as a clear cue of what's inside[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=An%20accordion%20is%20typically%20made,up%20of%20three%20elements)[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Accordions%20are%20a%20type%20of,interface%20design). This empowers users with **control** over what details to reveal, aligning with the principle of user freedom[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Accordions%20are%20a%20type%20of,interface%20design). However, we will be cautious not to bury critical information such that users have to open dozens of accordions to find what they need[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Summary%3A%C2%A0%20While%20accordions%20can%20simplify,access%20content%20under%20several%20accordions). That's why the search/filter is important to quickly drill down, and why we might auto-expand a single result if it's the only hit, etc. The accordion approach will **reduce cognitive load** by chunking information[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Reducing%20Clutter), which is perfect for ontologies where each class's details are a chunk.
- **Graph View and Interaction:** The graph-based interface will be accessible via a toggle or tab (e.g., a "Visualize" button that opens the graph panel). We want this graph to be interactive: users can click a node (class) to see its name and perhaps a tooltip of its description, double-click or a button to "Focus" which could either bring up the detail view for that class next to the graph or expand that node's neighbors. We will include a legend or color scheme to differentiate elements: for example, **blue circles for classes**, **orange squares for datatype properties**, **green diamonds for individuals** (this is inspired by Protégé and VOWL iconography[linkedin.com](https://www.linkedin.com/pulse/exploring-owl-ontologies-visually-paradigm-shift-nicolas-figay-telxe#:~:text=Legacy%20ways%20for%20visualizing%20Properties)). Dashed lines could indicate subclass relationships, solid lines for object property relations (with labels on the lines), etc., consistent with visual notations. A _Filter_ UI on the graph (like WebVOWL provides【19†look】) will let users hide certain categories of nodes (e.g., toggle visibility of individuals or annotation nodes if they clutter the view) or filter by ontology module. The graph should support pan/zoom and maybe a fullscreen mode for complex ontologies. Users can also search within the graph view (e.g., highlight a node by name). The combination of graph and text views addresses different user preferences: some may gravitate to the **graph for an overview**, while others prefer the **list for precise info** - our tool offers both, and they are synchronized for consistency.

_Prototype of an interactive ontology graph (WebVOWL example). Each circle represents a class (with subclass links shown by arrows and other relationships as labeled lines). Controls at the bottom allow searching, filtering, and adjusting the layout. In our tool's graph view, users will be able to explore in a similar manner - selecting nodes to see details, filtering the view, and visually discovering relationships._[dgarijo.github.io](https://dgarijo.github.io/Widoco/doc/gallery/#:~:text=)[semantic-web-journal.net](https://www.semantic-web-journal.net/system/files/swj1114.pdf#:~:text=the%20visual%20scope%20and%20completeness,intuitive%20and%20comprehensible%20ontology%20visualizations)

- **Performance Considerations:** LiveView will handle most interactions server-side, but we need to ensure the interface remains snappy. We will use **debouncing** for the search input so it doesn't flood the server with keystrokes, and perhaps limit how many results to render (if huge ontologies, we might paginate the list or require a minimum of 2 characters to filter). The graph rendering will largely happen client-side (once the data is provided), using efficient canvas/SVG techniques. We'll also lazy-load heavy elements: e.g., the graph data might not be sent until the user actually opens the graph view. Likewise, if we have an expandable list of 500 classes, we might not render all at once - instead, we can partition by alphabet or allow virtual scrolling. These optimizations ensure the UI remains **responsive and fluid**.
- **Aesthetics and Usability:** The look-and-feel should be modern (flat design, good use of whitespace, perhaps a toggle for dark mode given developers often like dark themes). We will use clear typography and maybe visual icons for different entity types (class, property, etc., akin to Protégé's icons or FontAwesome icons). Tooltips can be added for any less obvious symbols. Each page/section will have a clear heading so users know what they're looking at (for example, the detail view might have "Class: Organization" at top). We'll follow accessibility guidelines too - ensuring sufficient color contrast (especially in graph colors), keyboard navigability (e.g., allow using arrow keys to navigate the accordion or tab key through links), and proper ARIA roles for accordions and tabs.
- **Guidance for Users:** Although the target users are tech-savvy, not all are ontology experts. So, we might include a brief **help section or onboarding tips**. For instance, a "Help" popup could explain how to read the graph notation (what dashed vs solid line means, etc.) and remind that clicking items will navigate to their details. Similarly, the documentation page could start with an introduction to what the ontology is about and how the documentation is organized, so users can orient themselves. This aligns with Nielsen Norman's guidance that pages should promptly communicate what users can expect to find[nngroup.com](https://www.nngroup.com/articles/accordions-on-desktop/#:~:text=Just%20like%20how%20animals%20forage,empowering%20them%20to%20navigate%20with).

**Conclusion**

By combining a **textual accordion-based explorer** and an **interactive graph viewer**, our Phoenix LiveView-powered tool will provide a comprehensive yet user-friendly documentation platform for OWL ontologies. Domain experts will be able to quickly find classes and understand their meaning and connections, while also having the option to visually explore the ontology's structure. The modern UX touches - live search filters, collapsible sections, intuitive icons, and instant updates - ensure that the experience feels smooth and efficient, in line with contemporary web applications. Importantly, the tool remains faithful to the full OWL schema of the ontologies, so no information is lost; this means it can serve both newcomers (who might only pay attention to labels and hierarchy) and seasoned ontology developers (who might look for specific axioms or property details).

In summary, this design leverages best practices from existing ontology documentation generators (completeness of content with cross-references[ceur-ws.org](https://ceur-ws.org/Vol-932/paper12.pdf#:~:text=is%20an%20online%20service%20that,usually%20start%20by%20consulting%20its)) and state-of-the-art visualization research (usability of visual ontology exploration[semantic-web-journal.net](https://www.semantic-web-journal.net/system/files/swj1114.pdf#:~:text=ontologies,intuitive%20and%20comprehensible%20ontology%20visualizations)[linkedin.com](https://www.linkedin.com/pulse/exploring-owl-ontologies-visually-paradigm-shift-nicolas-figay-telxe#:~:text=Why%20Visual%20Exploration%20Matters%3A)), all wrapped in a dynamic web application framework. The result will be an **innovative ontology documentation tool** with its own modern look and feel, providing the best possible user experience for exploring the _elixir-core_ ontology and its related modules.
